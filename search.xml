<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[@就是想喷自己]]></title>
      <url>%2F2017%2F04%2F14%2F%E5%B0%B1%E6%98%AF%E6%83%B3%E5%96%B7%E8%87%AA%E5%B7%B1%2F</url>
      <content type="text"><![CDATA[垃圾！废物！菜逼！能干好个什么事？！！拿不到个offer，更别说以后的事情？？活该你他妈这样那样的不顺！不知道你他妈一天天的在干什么事情！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[@Java面试考点归纳]]></title>
      <url>%2F2017%2F04%2F10%2FJava%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E5%BD%92%E7%BA%B3%2F</url>
      <content type="text"><![CDATA[整理自牛客网2017Java春招备战计划①Java面试常考题 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 JDK和JRE的区别是什么？ Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 是否可以在static环境中访问非static变量？ static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 Java支持的数据类型有哪些？什么是自动拆装箱？ Java语言支持的8种基本数据类型是：byteshortintlongfloatdoublebooleanchar自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？ Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。 Java支持多继承么？ Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 接口和抽象类的区别是什么？ Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。抽象类可以在不提供接口方法实现的情况下实现接口。Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。也可以参考JDK8中抽象类和接口的区别 什么是值传递和引用传递？ 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.一般认为,java内的传递都是值传递. 进程和线程的区别是什么？ 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。 创建线程有几种不同的方式？你喜欢哪一种？为什么？ 有三种方式可以用来创建线程：继承Thread类实现Runnable接口应用程序可以使用Executor框架来创建线程池实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 概括的解释下线程的几种可用状态。 新建( new )：新创建了一个线程对象。 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 同步方法和同步代码块的区别是什么？ 区别：同步方法默认用this或者当前类class对象作为锁；同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法； 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。在java虚拟机中，每个对象（Object和class）通过某种逻辑关联监视器，每个监视器个一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁。一旦方法或者代码块被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在过去锁之前不允许执行该部分的代码。另外java还提供了显示监视器（Lock）和隐式监视器（synchronezed）两种锁方案。 什么是死锁(deadlock)？ 两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。 如何确保N个线程可以访问N个资源同时又不导致死锁？ 使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 Java集合类框架的基本接口有哪些？ 集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。 为什么集合类没有实现Cloneable和Serializable接口？ 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 什么是迭代器(Iterator)？ Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。 Iterator和ListIterator的区别是什么？ 下面列出了他们的区别：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 Java中的HashMap的工作原理是什么？ Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。HashMap的底层是用hash数组和单向链表实现的,当调用put方法时，首先计算key的hashcode，定位到合适的数组索引，然后再在该索引上的单向链表进行循环遍历用equals比较key是否存在，如果key值对应的hashcode相同，则会使用equals函数比较key，如果返回true，则新的value值覆盖原来的值；如果返回false，则插入单向链表的头部，而不是向后追加。这一点会涉及到后面多线程安全的一些问题。HashMap的两个重要属性是容量capacity和负载因子loadfactor，默认值分布为16和0.75，当容器中的元素个数大于capacity*loadfactor时，容器会进行扩容resize为2n，在初始化Hashmap时可以对着两个值进行修改，负载因子0.75被证明为是性能比较好的取值，通常不会修改，那么只有初始容量capacity会导致频繁的扩容行为，这是非常耗费资源的操作，所以，如果事先能估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，以防止频繁的resize操作影响性能。 hashCode()和equals()方法的重要性体现在什么地方？ Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 HashMap和Hashtable有什么区别？ HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：HashMap允许键和值是null，而Hashtable不允许键或者值是null。Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。一般认为Hashtable是一个遗留的类 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？ 下面列出了Array和ArrayList的不同点：Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。Array大小是固定的，ArrayList的大小是动态变化的。ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。而且还有一个地方是必须知道的，就是如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。 ArrayList和LinkedList有什么区别？ ArrayList和LinkedList都实现了List接口，他们有以下的不同点：ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素链表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 Comparable和Comparator接口是干什么的？列出它们的区别。 Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 什么是Java优先级队列(Priority Queue)？ PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？ 大O符号表示一个程序运行时所需要的渐进时间复杂度上界。其函数表示是：对于函数f(n),g(n),如果存在一个常数c，使得f(n)&lt;=c*g(n),则f(n)=O(g(n));大O描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。大O还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大O符号基于时间，内存，性能选择最好的实现。大O符号可以对大量数据性能给予一个很好的说明。。 如何权衡是使用无序的数组还是有序的数组？ 有序数组最大的好处在于查找的时间复杂度是O(logn)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。 Java集合类框架的最佳实践有哪些？ 根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。编程的时候接口优于实现。底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 Enumeration接口和Iterator接口的区别有哪些？ Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。 HashSet和TreeSet有什么区别？ HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 Java中垃圾回收有什么目的？什么时候进行垃圾回收？ 目的：回收堆内存中不再使用的对象，释放资源回收时间：当对象永久地失去引用后，系统会在合适的时候回收它所占的内存 System.gc()和Runtime.gc()会做什么事情？ 这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。调用 System.gc() 实际上等效于调用： Runtime.getRuntime().gc()java.lang.System.gc()只是java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。唯一要能说有什么不同那就是在字节码层面上调用前者比调用后者短一点点，前者是1条字节码而后者是2条 finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法 但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。finalize是Object类的一个方法，该方法在Object类中的声明 protected void finalize() throws Throwable { } 在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间。 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 不会，在下一个垃圾回收周期中，这个对象将是可被回收的。不会立即释放对象占用的内存。如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，而垃圾收集器是运行在后台的线程，只有当用户线程运行到安全点(safepoint)或者安全区域才会扫描对象引用关系，扫描到对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些对象是可恢复的（在finalize方法中恢复引用）。只有确定了对象无法恢复引用的时候才会清除对象内存。 Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。虚拟机中的共划分为三个代：年轻代（Young Generation）、年老代（OldGeneration）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。年轻代:所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。年老代:在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。持久代:用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ 吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 在Java中，对象什么时候可以被垃圾回收？ 当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。当没有任何对象的引用指向对象时在一个不可预期的时间内对象才会被回收.当一个对象到GCRoots不可达时，在下一个垃圾回收周期中尝试回收该对象，如果该对象重写了finalize()方法，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写finalize()方法或者已经执行过这个方法，也自救失败,该对象将会被回收。从GC Root对象开始搜索，搜索不到对象，并进行第一次标记、清理后，仍然没有复活的对象，那么这个对象可以被回收。 JVM的永久代中会发生垃圾回收么？ 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区) Java中的两种异常类型是什么？他们有什么区别？ Throwable包含了错误(Error)和异常(Excetion两类)Exception又包含了运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)(1) Error是程序无法处理了, 如果OutOfMemoryError、OutOfMemoryError等等,这些异常发生时, java虚拟机一般会终止线程 .(2) 运行时异常都是RuntimeException类及其子类,如NullPointerException、IndexOutOfBoundsException等, 这些异常是不检查的异常,运行异常的特点是 Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try…catch语句捕获它，也没有用throws字句声明抛出它，还是会编译通过。是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉. 这些错误一般是由程序的逻辑错误引起的, 程序应该从逻辑角度去尽量避免.(3) 检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的,否则不能通过编译. 如IOException、SQLException等.除了运行异常外，其他异常都属于受检查异常，这种异常的特点是要么用 try…catch捕获处理，要么用throws语句声明抛出，否则编译不会通过。两者的区别非检查异常表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行了错误的操作。一旦出现错误，建议让程序终止。受检查异常表示程序可以处理的异常。如果抛出异常的方法本身不处理或者不能处理它，那么方法的调用者就必须去处理该异常，否则调用会出错，连编译也无法通过。对于运行异常，建议不要用try…catch…捕获处理，应该在程序开发调试的过程中尽量的避免，当然有一些必须要处理的，自己知道了那个部分会出现异常，而这种异常你要把它处理的你想要的结果，例如：空值处理。 Java中Exception和Error有什么区别？ Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。Error ：表示由 JVM 所侦测到的无法预期的错误，由于这是属于 JVM 层次的严重错误 ，导致 JVM 无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。Exception ：包括runtimeException和受检异常，checked 异常也就是我们经常遇到的 IO 异常，以及 SQL 异常都是这种异常。 对于这种异常， JAVA编译器强制要求我们必需对出现的这些异常进行 catch 。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。但是另外一种异常：runtimeexception，也称运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过 NullPointerException 异常，它就是运行时异常，并且这种异常还是最常见的异常之一。 throw和throws有什么区别？ throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。1.Throw用于抛出异常对象，后面跟的时异常对象。是语句抛出一个异常。多用在函数内。语法：throw(异常对象) throw e; 2.Throws是方法可能抛出异常的声明（用在声明方法时，表示该方法可能要抛出异常）语法：修饰符 返回值类型 方法名 参数类型 throws异常类 public void test throws Exception1,Exception2(){} 异常处理完成以后，Exception对象会发生什么变化？ Exception对象会在下一个垃圾回收过程中被回收掉。 finally代码块和finalize()方法有什么区别？ 无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。 什么是Applet？ java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。 解释一下Applet的生命周期 applet可以经历下面的状态：Init：每次被载入的时候都会被初始化。Start：开始执行applet。Stop：结束执行applet。Destroy：卸载applet之前，做最后的清理工作。 当applet被载入的时候会发生什么？ 首先，创建applet控制类的实例，然后初始化applet，最后开始运行。 Applet和普通的Java应用程序有什么区别？ applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。 Java applet有哪些限制条件？ 主要是由于安全的原因，给applet施加了以下的限制：applet不能够载入类库或者定义本地方法。applet不能在宿主机上读写文件。applet不能读取特定的系统属性。applet不能发起网络连接，除非是跟宿主机。applet不能够开启宿主机上其他任何的程序。 什么是不受信任的applet？ 不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。 从网络上加载的applet和从本地文件系统加载的applet有什么区别？ 当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制。当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的。从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。 applet类加载器是什么？它会做哪些工作？ 当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。 applet安全管理器是什么？它会做哪些工作？ applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。 弹出式选择菜单(Choice)和列表(List)有什么区别 Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。 什么是布局管理器？ 布局管理器用来在容器中组织组件。java.awt包中大约有FlowLayout 流式布局BorderLayout 边框式布局GridLayout 网格布局CardLayout 卡片布局GridBagLayout 复杂的网格布局javax.swing包中大约有如下布局BoxLayout 盒式布局OverlayLayout 重叠布局ScrollPaneLayout 类JScrollPane使用的布局管理器ViewportLayout 类JViewport使用的布局管理器 滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？ Scrollbar是一个组件，不是容器。而ScrollPane是容器。ScrollPane自己处理滚动事件。 哪些Swing的方法是线程安全的？ 只有3个线程安全的方法： repaint(), revalidate(), invalidate()。 说出三种支持重绘(painting)的组件。 Canvas, Frame, Panel,和Applet支持重绘。 什么是裁剪(clipping)？ 限制在一个给定的区域或者形状的绘图操作就做裁剪。 MenuItem和CheckboxMenuItem的区别是什么？ CheckboxMenuItem类继承自MenuItem类，支持菜单选项可以选中或者不选中。 边缘布局(BorderLayout)里面的元素是如何布局的？ BorderLayout里面的元素是按照容器的东西南北中进行布局的。 网格包布局(GridBagLayout)里面的元素是如何布局的？ GridBagLayout里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于1行或一列。因此，行数和列数可以有不同的大小。 Window和Frame有什么区别？ Frame类继承了Window类，它定义了一个可以有菜单栏的主应用窗口。 裁剪(clipping)和重绘(repainting)有什么联系？ 当窗口被AWT重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。 事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？ 事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。 GUI组件如何来处理它自己的事件？ GUI组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。 Java的布局管理器比传统的窗口系统有哪些优势？ Java使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。 Java的Swing组件使用了哪种设计模式？ Java中的Swing组件使用了MVC(视图-模型-控制器)设计模式。 什么是JDBC？ JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。JDBC（Java Data BaseConnectivity,java数据库连接）是一种用于执行SQL语句的JavaAPI，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序JDBC（Java DataBase Connectivity）,是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过JDBC技术，开发人员可以用纯Java语言和标准的SQL语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。通常情况下使用JDBC完成以下操作：1.同数据库建立连接；2.向数据库发送SQL语句；3.处理从数据库返回的结果；JDBC具有下列优点：1.JDBC与ODBC(Open Database Connectivity，即开放数据库互连）十分相似，便于软件开发人员理解；2.JDBC使软件开发人员从复杂的驱动程序编写工作中解脱出来，可以完全专注于业务逻辑开发；3.JDBC支持多种关系型数据库，大大增加了软件的可移植性；4.JDBC API是面向对象的，软件开发人员可以将常用的方法进行二次封装，从而提高代码的重用性； 解释下驱动(Driver)在JDBC中的角色。 JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 Class.forName()方法有什么作用？ 初始化参数指定的类，并且返回此类对应的Class 对象在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。但是使用newInstance()方法的时候，就必须保证：1、这个类已经加载；2、这个类已经连接了。而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载java API的那个加载器。 PreparedStatement比Statement有什么优势？ PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。PreparedStatements是预编译的，PreparedStatements实例包涵已编译的sql语句，所以其执行速度要快于statement对象。PreparedStatements作为statement的子类，继承了statement的所有方法，三种方法，excute,excuteQuery和excuteUpdate已被更改以使之不再需要参数。PreparedStatements的代码可读性，可维护性强于statement.极大的提高了安全性.可以防止sql注入。 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？ CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是： Connection.prepareCall(); 数据库连接池是什么意思？ 像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 什么是RMI？ Java远程方法调用(Java RMI)是Java API对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的Java RMI（Remote Method Invocation）–Java的远程方法调用是Java所特有的分布式计算技术，它允许运行在一个Java虚拟机上的对象调用运行在另一个Java虚拟机上的对象的方法，从而使Java编程人员可以方便地在网络环境中作分布式计算。面向对象设计要求每个任务由最适合该任务的对象执行，RMI将这个概念更深入了一步，使任务可以在最适合该任务的机器上完成。RMI定义了一组远程接口，可以用于生成远程对象。客户机可以象调用本地对象的方法一样用相同的语法调用远程对象。RMIAPI提供的类和方法可以处理所有访问远程方法的基础通信和参数引用要求的串行化。 使用RMI开发步骤： 定义一个远程接口（远程接口必须继承接口，每个方法必须抛出远程异常，方法参数和方法返回值都必须是可序列化的） 实现远程接口 定义使用远程对象的客户程序 产生远程访问对象的桩和框 注册远程对象 运行服务器和客户程序 RMI体系结构的基本原则是什么？ RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。 RMI体系结构分哪几层？ RMI体系结构分以下几层：存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。 RMI中的远程接口(Remote Interface)扮演了什么样的角色？ 远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。 java.rmi.Naming类扮演了什么样的角色？ java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。 RMI的绑定(Binding)是什么意思？ 绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。 Naming类的bind()和rebind()方法有什么区别？ bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。 让RMI程序能正确运行有哪些步骤？ 为了让RMI程序能正确运行必须要包含以下几个步骤：编译所有的源文件。使用rmic生成stub。启动rmiregistry。启动RMI服务器。运行客户端程序。 RMI的stub扮演了什么样的角色？ 远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤：初始化到包含了远程对象的JVM的连接。序列化参数到远程的JVM。等待方法调用和执行的结果。反序列化返回的值或者是方法没有执行成功情况下的异常。把值返回给调用者。 什么是分布式垃圾回收(DGC)？它是如何工作的？ DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。 RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？ RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。 解释下Marshalling和demarshalling。 当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。 解释下Serialization和Deserialization。 Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘而把对象扁平化的一种方式，反序列化是从磁盘上读出来并重建对象，反序列化是把对象从扁平状态转化成活动对象的相反的步骤。序列化，实现序列化和反序列化的对象必须实现serializable接口，序列化是将对象变成字节流，存储到磁盘或网络。反序列化是序列化的反过程。 什么是Servlet？ Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。servlet是基于java语言的web服务器端编程技术，是sun提供的一种实现动态网页的解决方案。servlet是运行在servlet容器中的java类，它能处理客户端的http请求并产生http响应。 说一下Servlet的体系结构。 所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。Servlet详解 Applet和Servlet有什么区别？ Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。 GenericServlet和HttpServlet有什么区别？ GenericServlet是一个通用的协议无关的Servlet，它实现了Servlet和ServletConfig接口。继承自GenericServlet的Servlet应该要覆盖service()方法。最后，为了开发一个能用在网页上服务于使用HTTP协议请求的Servlet，你的Servlet必须要继承自HttpServlet.GenericServlet类实现了Servlet和ServletConfig接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet类来简化程序的代码，但需要实现service()方法。HeepServlet类继承了GeneriServlet类，为实际开发中大多数用Servlet处理 HTTP请求的应用灵活的方法。 解释下Servlet的生命周期。 对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet的destroy()方法把Servlet删除掉。Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。②装载并创建该Servlet的一个实例对象。③调用Servlet实例对象的init()方法。④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 doGet()方法和doPost()方法有什么区别？ doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。 什么是Web应用程序？ Web应用程序是对Web或者是应用服务器的动态扩展。有两种类型的Web应用：面向表现的和面向服务的。面向表现的Web应用程序会产生包含了很多种标记语言和动态内容的交互的web页面作为对请求的响应。而面向服务的Web应用实现了Web服务的端点(endpoint)。一般来说，一个Web应用可以看成是一组安装在服务器URL名称空间的特定子集下面的Servlet的集合。Web应用程序是一种可以通过Web访问的应用程序。Web应用程序的一个最大好处是用户很容易访问应用程序。用户只需要有浏览器即可，不需要再安装其他软件。一个Web应用程序是由完成特定任务的各种Web组件（web components)构成的并通过Web将服务展示给外界。在实际应用中，Web应用程序是由多个Servlet、JSP页面、HTML文件以及图像文件等组成。所有这些组件相互协调为用户提供一组完整的服务。 什么是服务端包含(Server Side Include)？ 服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。 什么是Servlet链(Servlet Chaining)？ Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。 如何知道是哪一个客户端的机器正在请求你的Servlet？ ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。 HTTP响应的结构是怎么样的？ HTTP响应由三个部分组成：状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。 什么是cookie？session和cookie有什么区别？ cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和cookie一同给服务器。服务器检查该cookie，从而判断用户的状态。服务器还可以根据需要修改cookie的内容。session是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。如果说cookie机制是通过检查客户身上的“通信证”，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。 浏览器和Servlet通信使用的是什么协议？ 浏览器和Servlet通信使用的是HTTP协议。 什么是HTTP隧道？ HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。 sendRedirect()和forward()方法有什么区别？ sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。保存在request域中的数据，只能通过转发技术，才能在其他Servlet界面获取到数据。 什么是URL编码和URL解码？ URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。 什么是JSP页面？ JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。 JSP请求是如何被处理的？ 浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。客户端通过浏览器发送jsp请求，服务器端接受到请求后，判断是否是第一次请求该页面，或者该页面是否改变，若是，服务器将jsp页面翻译为servlet，jvm将servlet编译为.class文件，字节码文件加载到服务器内存上执行，服务器将处理结果以.html页面的形式返回给客户端，若该页面不是第一次请求，则省略翻译和编译的步骤，直接执行。 JSP有什么优点？ 下面列出了使用JSP的优点：JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。JSP页面可以被预编译。JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。 什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？ Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在 &lt;%@ 和 %&gt;之间的。下面列出了不同类型的Directive：包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。Taglib指令： 用来声明页面中使用的自定义的标签库。 什么是JSP动作(JSP action)？ JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：jsp:include-当JSP页面被请求的时候包含一个文件。jsp:useBean-找出或者是初始化Javabean。jsp:setProperty-设置JavaBean的属性。jsp:getProperty-获取JavaBean的属性。jsp:forward-把请求转发到新的页面。jsp:plugin-产生特定浏览器的代码。 什么是Scriptlets？ JSP技术中，scriptlet是嵌入在JSP页面中的一段Java代码。scriptlet是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的scriplet。 声明(Decalaration)在哪里？ 声明跟Java中的变量声明很相似，它用来声明随后要被表达式或者scriptlet使用的变量。添加的声明必须要用开始和结束标签包起来。 什么是表达式(Expression)？ JSP表达式是Web服务器把脚本语言表达式的值转化成一个String对象，插入到返回给客户端的数据流中。表达式是在&lt;%=和%&gt;这两个标签之间定义的。 隐含对象是什么意思？有哪些隐含对象？ JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象：applicationpagerequestresponsesessionexceptionoutconfigpageContext 面向对象软件开发的优点有哪些？ 代码开发模块化，更易维护和修改。代码复用。增强代码的可靠性和灵活性。增加代码的可理解性。面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。 封装的定义和好处有哪些？ 封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。下面列出了使用封装的一些好处：通过隐藏对象的属性来保护对象内部的状态。提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。禁止对象之间的不良交互提高模块化。 多态的定义？ 多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。 继承的定义？ 继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。 抽象的定义？抽象和封装的不同点？ 抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[@4-7月时间安排，梦想开始的地方]]></title>
      <url>%2F2017%2F04%2F10%2F4-7%E6%9C%88%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92%EF%BC%8C%E6%A2%A6%E6%83%B3%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9%2F</url>
      <content type="text"><![CDATA[这三个月的时间安排最近的状态是很不好，没有了那股拼劲儿，开始松懈了，恋爱的力量果然是伟大的，红颜祸水。就像以前说的，我不会做一辈子程序员，最多也就干十年，上了大学，至少得拿出一点成果来，那么找个好的工作给家里一个交代，给自己一个交代，就是最需要做的。我相信自己不会一直这样穷下去，但是一个阶段有一个阶段的任务，我目前的任务就是要好好学习，找一个好的工作！人生这么长，变数还很多，或许这也只是一个小插曲，我应该自信点。三个月，一步一个脚印，找个实习应该是足够了。剩下的，还有大四一年，相信自己可以的。曾经觉得自己那么牛逼，不找到bat不去，现在却是落魄到连一家小公司都没找到，想想还挺悲哀的。问题出在自己身上，首先没有静下心来取认真学习，三分钟热度，其次，没有抓住机会和人家一同学习，缺少交流自己一个人埋头苦干是真的不行，最后，用来安慰一下自己，大概时机未到吧。人生就是这样子，没有人可以一帆风顺下去，这只是我生活中经历的一次失败而已，要克服困难，一寸一寸走下去，如果中途放弃，将永远走不到终点，所以即使再困难，经历再多次失败，都不能灰心。 时间表 7：40-8：00 起床 8：00-8：30 吃饭每天的早饭都要好好去吃，三分练，七分吃。 8：30-12：00 上课或者学习这学期的课程还是蛮重要的，上课能认真听讲就好好听，不能就抓紧时间自己看书 12：00-14：00 吃午饭+休息+闲事睡觉这东西，只要没死就可以先不睡。自由点安排吧。 14：00-18：00 学习 18：00-19：00 吃饭+闲事 19：00-22：00 学习晚饭后想去打球可以去。 22：00-23：00 健身这个每天的功课不能少。 23：00-23：30 洗澡速度。 23：30-24：00 安排第二天的任务还是要细分任务，每天有个小目标，才会有效率。 （暂时先这样子了，后面补充）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[@Java学习之路(二)]]></title>
      <url>%2F2017%2F04%2F04%2FJava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[计算机基础：数据机构基础：主要学习： 向量，链表，栈，队列和堆，词典。熟悉 树，二叉搜索树。熟悉 图，有向图，无向图，基本概念 二叉搜索A，B，C类熟练，9大排序熟悉。 树的前中后，层次，之字，最短路。 KMP等字符串算法。 操作系统： 主要学习： 进程，线程，进程线程区别。进程间通信 进程调度算法理解 存储，虚拟内存，分页分段，内存调度算法 文件系统，链式，索引 死锁：原因，避免，解除k Linux基本操作命令，会一门脚本编程：shell，Python 计算机网络：主要学习：1. 网络分层：五层，七层，四层等2. 网络层：IP分类，子网划分，超网。ARP协议，ICMP协议。理解内部网关和外部网关，vpn等3. 运输层：端口，UDP协议理解，TCP协议理解，三次握手，四次断开。4. 应用层：了解常用协议使用的端口和底层协议。5. 更加深入理解：TCP/IP 对拥塞控制，滑动窗口，如何实现可靠等。 基础算法：主要学习： 理解大O等记号 动态规划如：几类背包问题最好有现成的代码用于笔试。最长公共子序列 贪心算法：理解赫夫曼编码（笔试常考概念） B树B+树用于理解数据库索引 常用的图算法：广度优先，深度优先，最短路径算法（最好有现成的代码），最小生成树。 JAVA知识基础：JAVA基础推荐书籍：编程思想 掌握java常用技术，io、多线程、反射、常用集合框架 对处理输入输出的IO进行熟悉，用于笔试 对Iterator，Iterable和Comparable,Comparator了解，以及常用集合的遍历和排序。 对NIO一定要熟悉，以及了解JMS和RPC 对JAVA基础概念要熟悉，比如抽象类和接口区别等，这些熟记。 JAVA源码 hashmap，hashtable，concurrentHashMap源码以及区别 其他集合框架：linkedHashMap，LinkedHashSet，Copy-On-Write等 对Lock，Object，String等类的源码了解。 JAVA并发API推荐书籍：应付笔试面试：JAVA多线程编程与核心技术。真正神书：JAVA并发编程实战。Synchronize 和 Lock 的区别与用法 wait()和await() notify()和signal()，wait()和sleep()区别与用法 其他的API用法：yield，join等 voliate深入理解，以及CAS理解 JAVA锁底层实现：自旋锁，阻塞锁，可重入锁，偏向锁，等。 线程池和阻塞队列 以及一些常用的并发实现案例如生产者和消费者 理解JVM推荐书籍：深入理解JAVA虚拟机1. JAVA内存模型，哪个区域存放哪些内容2. 引用技术法和可达性分析法3. 对象的强、软、弱和虚引用区别与作用4. jvm垃圾回收机制，以及回收算法5. 常见的OOM和SOF的原因和解决方案，以及通过什么工具进行分析。6. 常见的JVM输入参数熟悉7. 了解GC停顿，逃逸分析，TLAB区，堆外内存等8. 常用垃圾收集器：G1，CMS等9. 了解常用性能监控工具：如visualvm jconsole等10. 必须熟悉虚拟机类加载机制，包括原理步骤，以及双亲委派方式的原理。 常规储备知识学习数据库：推荐书籍：sql入门：Mysql必知必会。深入理解：高性能Mysql 常用关联查询语法，自己所动手写几个 数据库索引深入认识和理解 JDBC学习 常用数据库调优手段：比如通过索引调优 InnoDB和MyISAM 区别 了解主键，外键，索引，唯一索引 了解索引、视图、触发器、游标和存储过程 常用关系型数据库和非关系型数据库：关系型了解：Mysql，Oracle 非关系型了解：redis，Hbase，monogodb等 设计模式：推荐书籍：设计模式之禅 单例模式的几种写法一定要会 JDK中对应的设计模式：如IO中的装饰模式和设配器模式等 框架中常用的设计模式：如Struts中的责任链模式，Spring中的工厂模式，动态代理模式等 了解6大设计原则 HTTP协议：推荐书籍：HTTP权威指南 什么是HTTP，协议版本等 学会使用浏览器查看HTTP请求与响应 熟悉HTTP请求头和请求体 熟悉HTTP响应头和响应体 了解Rest风格 神一般的Spring：推荐书籍：Spring实战和Spring技术内幕 了解IOC原理和作用 了解AOP原理和作用 常用的XML配置 Spring事务原理和使用 SpringMVC 了解Spring的webflow，远程服务，rest，消息，安全等 新功能：Spring boot和cloud 后端学习之路WEB后端学习之路推荐书籍：可以选择一些SSH整合开发之类的 JSP和Servlet学习 XML和JSON解析学习 前端知识：HTML、css，js JDBC学习，文件上传\下载，JAVAMail等 可以利用jsp和Servlet开发简单项目 接着框架学习：Struts2，Hibernate，Spring以及相互整合开发 接着可以了解：SpringMvc，Mybatis，Lucene，shiro等 利用框架实现简单项目比如CMS。 服务架构学习之路（此部分笔试面试不一定学习）推荐书籍：分布式服务框架原理与实践和微服务设计1. 了解SOA和微服务2. 负载均衡：LVS，NGINX等3. RPC框架学习：RMI，Thrift等4. 消息框架学习：ActiveMq等5. Netty通信框架学习6. 服务框架：dubbo Hadoop学习之路（此部分笔试面试不一定学习）推荐书籍：Hadoop权威指南 熟悉mapReduce和HDfS Hadoop集群搭建 了解：zk，hive，hbase，pig，mahout等 zk几个常用作用如做注册中心，放配置信息等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[珍惜时间 好好学习]]></title>
      <url>%2F2017%2F04%2F03%2F%E7%8F%8D%E6%83%9C%E6%97%B6%E9%97%B4-%E5%A5%BD%E5%A5%BD%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[兄弟，最近状态欠佳啊，找实习的紧急日子，好像错过了不少东西呢。有个坏消息，好像hexo又崩了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[寒假学习计划]]></title>
      <url>%2F2017%2F01%2F18%2F%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[寒假的目标是完成SmartSchool的开发 SmartSchool开发准备工作： 后台开发的学习包括 看完电脑上的学习资料 完成学习过程中的每个项目 环境搭建把工作移到windows下，包括 MyEclipse的安装和破解 JDK的安装 服务器上环境的搭建，包括Tomcat,MySql]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016的年度总结]]></title>
      <url>%2F2016%2F12%2F31%2F2016%E7%9A%84%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[大二上学期，我加入了微客工作室，从php入门，接触到web后端开发。这一年，心里的目标一直很坚定，偶尔会动摇，但想到没有更好的路可以选择，对于互联网巨头公司的追求就更加强烈。一年时间，其实还是学了蛮多的东西，都在涉猎，遗憾的是没有深入去学习，没有实际的项目可以拿得出手。人家说一年时间，怎样怎样了，我就感觉好叼，一年原来就可以进步这么大。不过想想自己，一年时间，不也从什么都不懂的菜鸟，变成了对互联网疯狂热爱的菜鸟。 php 学了基本语法和web端的编程（快忘光了），没有接触到框架，在学习的过程中，不会搭建环境（现在想想蛮简单）就选择了集成的wamp，接触到了服务器apache的配置数据库mysql和SQL语言。整整磨叽了大二整个上学期，才算入了门，大二下学期到学校，写了自己第一个博客，前端代码是现成的，后台是自己一行一行敲出来的。 python 大二结束，在php的道路上走出去了一点点，我也不知道为什么会学习得那么慢。感觉自己好像已经什么都会了，又感觉自己其实什么都不会。总之，好像真的不喜欢这个。刚好遇到轩哥介绍，加入一个团队去做python web，学习python的同时，又入了Linux的坑，装双系统真是熬了我几天几夜。好多东西弄完就会忘记，因为遇到的问题不是那么常见，又很繁琐，所以写博客记录是很必要的。我也是有点懒。 java 学校开了java课，作为一个牛逼后台开发，怎么能不会java呢，python的项目最终还是夭折了，那就入java吧！有了前面的踩坑，这个学起来还是很快的。开始有了编程思想，看得懂报错，调bug有了经验和逻辑条理。 我最大的缺点，应该就是不够坚持，想得太多却没有踏实去做，大一那次选拔提前放弃导致后面的连锁反应，还有后面学习中遇到困难卡壳就会好多天不去解决，还有大方向上的失策，不坚持去好好学习一个东西，因为学到了瓶颈处？或许性格就是这样啊，劳资就是不在意这些，我自己认为那是对的就好！php就是垃圾，我就是不喜欢这种语音，所以选择python和java。想想这一切，也不是那么糟糕。这个社会人傻钱多的人也有那么多，要立足还是不难的。年少的梦想越来越远，但也不是没有机会。下学期来就是找实习了，但是在这之前，还有很多东西要做。加油了。珍惜时间，认真学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[win10下安装tomcat]]></title>
      <url>%2F2016%2F12%2F02%2Fwin10%E4%B8%8B%E5%AE%89%E8%A3%85tomcat%2F</url>
      <content type="text"><![CDATA[下载tomcat用浏览器打开tomcat官网：http://tomcat.apache.org/在左侧的导航栏Download下方选择最新的Tomcat 9，点击页面下方的“ 64-bit Windows zip (pgp, md5, sha1)“进行下下载完成 安装tomcat解压后即可使用 配置环境变量 配置jdk的环境变量(博客中已有) 在系统变量里新建变量名：CATALINA_BASE，变量值：E:\editor\apache-tomcat-9.0.0.M13 在系统变量里新建变量名：CATALINA_HOME，变量值：E:\editor\apache-tomcat-9.0.0.M13 在系统变量里打开PATH，添加变量值：%CATALINA_HOME%\lib;%CATALINA_HOME%\bin 打开cmd，进入tomcat下的bin目录，执行“service.bat install” 附：service卸载命令：service.bat remove 启动tomcat 尝试用git bash在bin目录下输入命令，失败，还是cmd才可以。！点击bin目录下的startup.bat，或者在bin目录下面启动cmd，输入startup.bat,会出现cmd窗口显示启动信息，如果窗口闪退，则启动会失败！停止服务即是shutdown.bat在linux下，对应的启动和停止时startup.sh和shutdown.sh两个命令 测试安装是否成功使用浏览器打开http://localhost:8080/，若成功打开则表示tomcat安装且运行成功 教程马克]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[win10下搭建java开发环境]]></title>
      <url>%2F2016%2F12%2F02%2Fwin10%E4%B8%8B%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[下载地址jdk和jre官方网址：http://www.oracle.com/technetwork/java/javase/downloads/index.html根据你的系统选择你需要下载的jdk，32位系统对应x86，64位系统对应x64下载完后得到一个可执行文件，点击运行进入安装 安装 安装JDK选择你要安装到的路径，注意这个路径不能包含中文名这里我们可以通过“更改”选择自己想要安装到的目录，然后点击下一步即可。到这里我们只安装了jdk，安装向导会检查到你未安装jre，然后提示你安装jre 安装JRE选择一个你喜欢的文件夹，注意这个文件夹不要是jdk安装目录，否则会覆盖掉jdk目录下的jre目录我们这里选择安装到和JDK同级的目录下，点击下一步之后即可完成安装，然后提示已成功安装 环境变量配置我的电脑→右键→属性→高级系统设置→环境变量 新建一个变量名为“JAVA_HOME”的系统变量，变量值为“E:\study\java”（jdk的安装目录，根据个人所安装的目录修改） 再新建一个变量名为“CLASSPATH”，变量值为“.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”的系统变量，注意前面的点号和分号都是有的3.打开“Path”系统变量，点击新建，添加“%JAVA_HOME%\bin”和“%JAVA_HOME%\jre\bin”两个系统变量。Path使得系统可以在任何路径下识别java命令（win7下Path打开后可能不是这样的页面，打开后需要手动输入这两个变量名，每个变量名都用英文分号隔开即可） 认证点击保存后，按window+R或者点击运行输入cmd，打开命令行窗口分别输入java和java -version和javac都正常运行即代表java已经正确安装，其中 java -version代表你安装的java的版本 如果出现类似”javac不是内部或外部命令”等提示语句，请再三检查你的环境变量是否正确配置，或者JDK和JRE安装目录是否重复，如果重复，可以选择再次运行下载的jdk安装程序重新安装。教程马克]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eclipse下tomcat服务器启动相关]]></title>
      <url>%2F2016%2F11%2F29%2Ftomcat%2F</url>
      <content type="text"><![CDATA[折腾了我好多天的问题,没想到随手一百度就解决了.. 读取配置文件位置在eclipse下新建的web项目,放在tomcat上运行,可以正常访问到项目界面,但是localhost:8080却访问不到原来这是eclipse的优化，它把Ttomcat的配置文件都COPY到自己一个隐藏的目录下了，当你用eclipse启动的时候，其实并不是启动Ttomcat下的startup,而是eclipse自己的COPY的那堆配置文件，所以，你用eclipse启动时，访问tomcat自带的主页会出404..metadata.plugins\org.eclipse.wst.server.core\tmp1这个就是ECLIPSE默认COPY配置文件存放的目录。所以因为eclipse自带tomcat只是copy了自己tomcat的配置文件，所以是访问不了tomcat主页的解决方法: 双击在Servers视图中的服务器,出现配置界面 在Server Locations一栏,默认是选中了第一个 Use workspace metadata.改为第二个就可以了.如果第二个为灰色的,可以删除这个服务器,重新部署一个,或者remove所有项目,再clear服务器,然后就可以了. 项目部署位置还有一个问题,打开tomcat的webapps目录,发现项目没有自动拷贝过来,平时学习无所谓,但如果项目需要移植发送,会很难找.metadata.plugins\org.eclipse.wst.server.core\tmp1\wtpwebapp这就是eclipse会默认部署项目到的工作目录.修改方法:在上一步的基础上,同时修改下面的Deploy path,修改为tomcat的webapps目录即可.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet学习]]></title>
      <url>%2F2016%2F11%2F27%2FServlet%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[#Servlet学习: 大纲 servlet的相关概念和接口 servlet的执行过程 servlet路径映射 缺省servlet servlet生命周期(重点) servlet自动加载 servlet线程安全 ServletConfig对象 servlet接口详解 ServletContext对象 如何开发一个servlet步骤 编写java类,继承HttpServlet类 123456789101112131415161718package cn.fayostyle.servlet1;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import sun.java2d.pipe.RenderQueue;public class First_Servlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write("This is the first Servlet!"); &#125;&#125; 重写doGet和doPost方法 Servlet程序交给tomcat服务器运行 Servlet程序的class字节码文件拷贝到WEB-INF/classes目录 在web.xml文件中进行12345678 &lt;servlet&gt; &lt;servlet-name&gt;First_Servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.fayostyle.servlet1.First_Servlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;First_Servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/first&lt;/url-pattern&gt; 在将Servlet部署到tomcat服务器中出现这个问题1、这个是因为server中已经存在了一个 把server视图打开删除以前那个就可以了2、在运行时删除以前的服务器,选中新建一个服务器就行了出现问题,将项目部署到了tomcat进行访问,却出现404,在eclipse上启动后,甚至连tomcat首页localhost:8080都访问不到. 一开始以为是自己的问题,没想到过了一天年后,重新开机打开eclipse运行又可以了….但是为何打开tomcat文件夹webapp目录,没有这个项目,也就是说没被拷贝过去.?通过反射: 构造FirstServlet对象 调用FirstServlet里面的方法 Servlet的映射路径匹配123456789&lt;servlet&gt; &lt;servlet-name&gt;First_Servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.fayostyle.servlet1.First_Servlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;First_Servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/first&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 精确匹配/first只能匹配http://localhost:8080/project_name/first /test/first只能匹配http://localhost:8080/project_name/test/first 模糊匹配 / 号为通配符,匹配任意路径,甚至为空也可以http://localhost:8080/project_name/*/test/ 匹配http://localhost:8080/project_name/test/ *.后缀名 *.do *.action *.html(伪静态:实际是一个Servlet) url-pattern要么以/开头,要么以*开头 不能同时使用两种模糊匹配如:/test/*.do 当输入的URL有多个servlet同时别匹配的情况下 精确匹配优先 以后缀名结尾的模糊匹配优先级最低 servlet缺省路径servlet的缺省路径实在tomcat服务器内置的一个路径.该路径对应的是一个DefaultServlet(缺省sservlet).这个缺省servlet的作用是用于解析web应用的静态资源文件当在url-pattern中配置一个/index.html,同时Webcontent下面也有一个index.html文件时输入http://localhost:8080/project_name/index..html会直接访问到servlet页面. 到当前projec_name应用下的web.xml文件中查找是否有匹配的url-pattern 如果没有匹配的url-pattern,则交给tomcat的内置的DefaultServlet处理 DefaultServlet程序到project_name应用的根目录下查找是否存在一个名为index.html的静态文件. 如果找到该文件,则读取文件内容,找不到返回404.结论:先找动态资源,再找静态资源 Servlet的生命周期即Servlet类对象什么时候创建,什么时候调用什么方法,什么时候调用方法进行销毁.Servlet的生命周期由tomcat服务器控制!第一次访问: 调用构造方法,servlet对象被创建. 只调用一次,这说明servlet在tomcat中是单例的. 创建完servlet,对象init方法被调用.只调用一次 每次发出请求时,service方法被调用继续访问:只调用service方法重新部署或者关闭tomcat服务器:destory方法被调用,销毁servlet对象.只调用一次 Servlet生命周期,在tomcat中的运行过程总结: 通过映射找到servlet-class的内容,得到字符串cn.fayostyle.servlet1.First_Servlet 通过反射构造First_Servlet对象 得到字节码对象Class clazz = class.forName(&quot;cn.fayostyle.servlet1.First_Servlet&quot;); 调用无参的构造方法来构造对象Object obj = class.newInstance(); —-servlet的构造方法被调用 创建ServletConfig对象,通过反射调用init()方法 得到方法对象Method m = clazz.getDaeclareMethod(&quot;init&quot;, ServletConfig.class); 调用方法m.invoke(obj, servletconfig); —–Servlet中的init方法被调用 创建request,response对象,通过反射调用service方法 得到方法对象 1Method m = clazz.getDeclareMethod(&quot;service&quot;,HttpServletRequest.class,HttpServletResponse.class); 调用方法m.invoke(obj, request, response); ——service方法被调用 服务器停止或者重新不熟web应用,通过反射调用destory()方法. 得到方法对象Method m = clazz.getDeclareMethod(&quot;destory&quot;, null); 调用方法m.invoke(obj,null); —–destory方法被调用 servlet对象自动加载 在servlet配置中增加[1-6 正整数,数字越大优先级越低] 字段 将会在tomcat服务器启动加载webapp的时候,提钱调用init()方法 有参的init方法和无参的init方法servlet对象在tomcat服务器中的运行机制,是单实例多线程要注意多线程安全,解决方案:加锁 synchronized ServletConfig对象 —-每个servlet只能获取属于自己的配置sml文件中的参数数据作用:主要用于加载servlet的初始化参数封装了web.xml中的数据,通过对象方法获取.一个web应用里面,可以有多个ServletConfig对象,一个Servlet配置,对应一个ServletConfig对象 ServletContext对象Servlet的上下文对象,表示一个当前的web应用环境一个web应用里面,只有一个ServletContext对象创建时间:加载web应用的时候,就创建了ServletContext对象.得到对象:从ServletConfig对象的getServletContext方法得到核心API的掌握 java.lang.String getContextPath() —-得到web应用路径.通常用在请求重定向的资源中response.sendRedirect(contextPath+ &quot;/index.html&quot;) java.lang.String getInitParameter(java.lang.String name)java.util.Enumeration getInitParameterNames() —-得到web应用的初始化参数,所有servlet都可以获取. 域对象有关的方法:域对象:作用是用于保存数据,获取数据.可以在不同的动态资源之间共享数据.保存数据: void setAttribute(java.lang.String name, java.lang.Object object)获取数据: java.lang.Object getAttribute(java.lang.String name)删除数据: void removeAttribute(java.lang.String name)ServletContext域对象: 作用范围在整个web应用中都有效HttpServletRequest域对象HttpSession域对象PageContext域对象项目中根据每个域对象作用范围不同,选择讲数据保存到不同的域对象中. 转发(跳转页面)RequestDispatcher getRequestDispather(java.lang.String path)1RequestDispather rd = thix.getServletContext().getRequestDispatcher("/index.html"); 与重定向的区别在于,转发的地址栏不会变,且只能转发到当前web应用内的资源,不能转发到当前web应用以外的资源,可以再转发过程中,把数据保存到request域对象中;而重定向地址栏会改变,且可以重定向到任意地址,不能把数据保存在request域对象中.如果要使用request域对象进行数据共享,只能使用转发技术]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[open vpn 搭建免流服务器]]></title>
      <url>%2F2016%2F11%2F24%2Fopen-vpn-%E6%90%AD%E5%BB%BA%E5%85%8D%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[准备工作 云服务器一台，我这里刚好使用腾讯的学生一元云服务器。重装操作系统，选择CentOS6.6 64位 Xshell软件 开始 首先使用Xshell软件连接到远程的服务器接下来填入用户名,密码(登录远端服务器的用户名和密码) 按照骚逼汪的教程,在terminal中输入wget http://sbwml.cn/vpn6;chmod +x vpn6;./vpn6中间需要用到授权码,就在网页上.这是常规VPS安装脚本, 接下来等待安装即可.中途会需要设置openvpn的连接账号和密码.即是到时候手机端连接的账号密码 安装完成后,复制返回的下载链接,在浏览器中打开下载到本地解压后打开,我们需要的文件是这个,需要在手机端的openvpn配置这个文件 手机上安装openvpn,导入OpenVPN配置文件,输入账号密码就可以连接了 至此结束在前面只建立了一个手机端的用户, 可以建立多个用户.在terminal中输入 echo 账号 密码 &gt;&gt;/passwd 即可新建一个用户 &gt;&gt;是在后面追加, &gt;是覆盖!注意不要弄错了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows10下安装myeclipse]]></title>
      <url>%2F2016%2F11%2F21%2Fwindows10%E4%B8%8B%E5%AE%89%E8%A3%85myeclipse%2F</url>
      <content type="text"><![CDATA[##下载myeclipse MyEclipse企业级工作平台（MyEclipse Enterprise Workbench ，简称MyEclipse）是对EclipseIDE的扩展，利用它我们可以在数据库和JavaEE的开发、发布以及应用程序服务器的整合方面极大的提高工作效率。它是功能丰富的JavaEE集成开发环境，包括了完备的编码、调试、测试和发布功能，完整支持HTML,Struts,JSP,CSS,Javascript,Spring,SQL,Hibernate。 MyEclipse 是一个十分优秀的用于开发Java, J2EE的 Eclipse 插件集合，MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持十分不错。MyEclipse目前支持Java Servlet,AJAX, JSP, JSF, Struts,Spring, Hibernate,EJB3,JDBC数据库链接工具等多项功能。可以说MyEclipse几乎囊括了目前所有主流开源产品的专属eclipse开发工具。 在结构上，MyEclipse的特征可以被分为7类： 1． JavaEE模型 2． WEB开发工具 3． EJB开发工具 4． 应用程序服务器的连接器 5． JavaEE项目部署服务 6． 数据库服务 7． MyEclipse整合帮助 对于以上每一种功能上的类别，在Eclipse中都有相应的功能部件，并通过一系列的插件来实现它们。MyEclipse结构上的这种模块化，可以让我们在不影响其他模块的情况下，对任一模块进行单独的扩展和升级。 简单而言，MyEclipse是Eclipse的插件，也是一款功能强大的JavaEE集成开发环境，支持代码编写、配置、测试以及除错，MyEclipse6.0以前版本需先安装Eclipse。MyEclipse6.0以后版本安装时不需安装Eclipse。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java web学习大纲]]></title>
      <url>%2F2016%2F11%2F21%2F%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2%2F</url>
      <content type="text"><![CDATA[java web学习大纲 花两个小时好好写写这篇文章，有个明确的学习路线 java开发环境搭建 java基础知识 JDBC/Servlet 数据库开发技术 EJB技术和企业级应用服务器的使用（如 WebSphere、Weblogic、Sun Applcation Server或JBOSS等，目前Sun Applcation Server 9.X和JBOSS) 主流框架 springMVC + ibatis + jQuery + Ajax java并发编程，一些中间件，如分布式缓存，RMS java开发环境搭建JDK下载和配置 windows下JDK的下载安装很简单，百度一下oracle官网下载地址，如果oracle下载太慢，也可以选择国内其他下载站，之后一路next就行了。 ubuntu系统下1sudo apt install java windows下，安装jdk需要配置环境变量，具体百度。ubuntu下可以不用配置，但最好还是配置，之后安装tomcat需要用到JAVA_HOME环境变量，eclipse不需要。 初学的话，不用IDE的确是很好的，一行一行敲下来会遇到很多问题，解决下来会对基本的语法和javaAPI的使用更为得心应手。比如：12BufferedReader buff = new BufferedReader(new InputStreamReader(System.in)); 将System.in传入的字节流，通过InputStreamReader转换流转换为字符流，放入缓冲区，一个程序只需要创建一个BufferedReader实例就可以多次使用buff.readLine()方法将输入读进缓冲区 eclipse的安装与配置 eclipse是一个以插件为主的开发IDE，在eclipse官网下载JAVASE版本，之后自行安装JAVAEE插件即可，也可以安装其他如C/C++的插件进行开发。 java web的开发，安装Myeclipse会更加利于开发，因为它已经集成了JAVAEE开发所需要的工具。详情可以戳windows下安装myeclipse tomcat的安装配置Mysql的安装配置##]]></content>
    </entry>

    
  
  
</search>
